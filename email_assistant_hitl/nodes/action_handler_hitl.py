"""Tool call interrupt handler for HITL."""

from langgraph.types import interrupt
from email_assistant_hitl.utils.state import GraphState
from email_assistant_hitl.helpers import parse_email, format_email_markdown
from email_assistant_hitl.helpers.hitl_helpers import format_tool_call_for_display
from email_assistant_hitl.tools import (
    write_email,
    schedule_meeting,
    check_calendar_availability,
    search_emails,
    search_events,
    update_event,
    Question,
)
from langgraph.store.base import BaseStore
from email_assistant_hitl.utils.memory import update_memory
from email_assistant_hitl.prompts.defaults import MEMORY_UPDATE_INSTRUCTIONS_REINFORCEMENT


tools_by_name = {
    "write_email": write_email,
    "schedule_meeting": schedule_meeting,
    "check_calendar_availability": check_calendar_availability,
    "search_emails": search_emails,
    "search_events": search_events,
    "update_event": update_event,
    "Question": Question,
}


def action_handler_hitl(state: GraphState, store: BaseStore) -> GraphState:
    """Handle interrupts for tool calls that require human review.
    
    This node examines tool calls from the agent and:
    1. Executes low-risk tools directly (like check_calendar_availability)
    2. Creates interrupts for high-risk tools (write_email, schedule_meeting, Question)
    3. Processes user responses (accept, edit, ignore, or respond with feedback)
    
    Args:
        state: The current graph state containing messages with tool calls.
        
    Returns:
        Updated state with tool results and optional workflow_should_end flag.
    """
    result = []
    
    should_end_workflow = False
    
    for tool_call in state["messages"][-1].tool_calls:
        
        hitl_tools = ["write_email", "schedule_meeting", "Question"]
        
        if tool_call["name"] not in hitl_tools:
            tool = tools_by_name[tool_call["name"]]
            observation = tool.invoke(tool_call["args"])
            result.append({
                "role": "tool",
                "content": observation,
                "tool_call_id": tool_call["id"]
            })
            continue
        
        email_input = state["email_input"]
        author, to, subject, email_thread = parse_email(email_input)
        original_email_markdown = format_email_markdown(subject, author, to, email_thread)
        
        tool_display = format_tool_call_for_display(tool_call)
        description = original_email_markdown + "\n---\n" + tool_display
        
        if tool_call["name"] == "write_email":
            config = {
                "allow_ignore": True,
                "allow_respond": True,
                "allow_edit": True,
                "allow_accept": True,
            }
        elif tool_call["name"] == "schedule_meeting":
            config = {
                "allow_ignore": True,
                "allow_respond": True,
                "allow_edit": True,
                "allow_accept": True,
            }
        elif tool_call["name"] == "Question":
            config = {
                "allow_ignore": True,
                "allow_respond": True,
                "allow_edit": False,
                "allow_accept": False,
            }
        else:
            raise ValueError(f"Unknown HITL tool: {tool_call['name']}")
        
        request = {
            "action_request": {
                "action": tool_call["name"],
                "args": tool_call["args"]
            },
            "config": config,
            "description": description,
        }
        
        response = interrupt([request])[0]
        
        if response["type"] == "accept":
            tool = tools_by_name[tool_call["name"]]
            observation = tool.invoke(tool_call["args"])
            result.append({
                "role": "tool",
                "content": observation,
                "tool_call_id": tool_call["id"]
            })
            
        elif response["type"] == "edit":
            tool = tools_by_name[tool_call["name"]]
            edited_args = response["args"]["args"]
            
            ai_message = state["messages"][-1]
            current_id = tool_call["id"]
            
            updated_tool_calls = [
                tc for tc in ai_message.tool_calls if tc["id"] != current_id
            ] + [
                {
                    "type": "tool_call",
                    "name": tool_call["name"],
                    "args": edited_args,
                    "id": current_id
                }
            ]
            
            if tool_call["name"] == "write_email":
                update_memory(store, ("email_assistant", "response_preferences"), [{
                    "role": "user",
                    "content": f"User edited the email response. Here is the initial email generated by the assistant: {tool_call['args']}. Here is the edited email: {edited_args}. Follow all instructions above, and remember: {MEMORY_UPDATE_INSTRUCTIONS_REINFORCEMENT}."
                }])
            elif tool_call["name"] == "schedule_meeting":
                update_memory(store, ("email_assistant", "cal_preferences"), [{
                    "role": "user",
                    "content": f"User edited the calendar invitation. Here is the initial calendar invitation generated by the assistant: {tool_call['args']}. Here is the edited calendar invitation: {edited_args}. Follow all instructions above, and remember: {MEMORY_UPDATE_INSTRUCTIONS_REINFORCEMENT}."
                }])
            
            result.append(ai_message.model_copy(update={"tool_calls": updated_tool_calls}))
            
            observation = tool.invoke(edited_args)
            result.append({
                "role": "tool",
                "content": observation,
                "tool_call_id": current_id
            })
            
        elif response["type"] == "ignore":
            if tool_call["name"] == "write_email":
                content = "User ignored this email draft. Ignore this email and end the workflow."
                update_memory(store, ("email_assistant", "triage_preferences"), state["messages"] + [{"role": "tool", "content": content, "tool_call_id": tool_call["id"]}] + [{
                    "role": "user",
                    "content": f"The user ignored the email draft. That means they did not want to respond to the email. Update the triage preferences to ensure emails of this type are not classified as respond. Follow all instructions above, and remember: {MEMORY_UPDATE_INSTRUCTIONS_REINFORCEMENT}."
                }])
            elif tool_call["name"] == "schedule_meeting":
                content = "User ignored this calendar meeting draft. Ignore this email and end the workflow."
                update_memory(store, ("email_assistant", "triage_preferences"), state["messages"] + [{"role": "tool", "content": content, "tool_call_id": tool_call["id"]}] + [{
                    "role": "user",
                    "content": f"The user ignored the calendar meeting draft. That means they did not want to schedule a meeting for this email. Update the triage preferences to ensure emails of this type are not classified as respond. Follow all instructions above, and remember: {MEMORY_UPDATE_INSTRUCTIONS_REINFORCEMENT}."
                }])
            elif tool_call["name"] == "Question":
                content = "User ignored this question. Ignore this email and end the workflow."
                update_memory(store, ("email_assistant", "triage_preferences"), state["messages"] + [{"role": "tool", "content": content, "tool_call_id": tool_call["id"]}] + [{
                    "role": "user",
                    "content": f"The user ignored the Question. That means they did not want to answer the question or deal with this email. Update the triage preferences to ensure emails of this type are not classified as respond. Follow all instructions above, and remember: {MEMORY_UPDATE_INSTRUCTIONS_REINFORCEMENT}."
                }])
            else:
                content = "User ignored this action. End the workflow."
            
            result.append({
                "role": "tool",
                "content": content,
                "tool_call_id": tool_call["id"]
            })
            should_end_workflow = True
            
        elif response["type"] == "response":
            user_feedback = response["args"]
            
            if tool_call["name"] == "write_email":
                content = f"User gave feedback, which we can incorporate into the email. Feedback: {user_feedback}"
                update_memory(store, ("email_assistant", "response_preferences"), state["messages"] + [{"role": "tool", "content": content, "tool_call_id": tool_call["id"]}] + [{
                    "role": "user",
                    "content": f"User gave feedback, which we can use to update the response preferences. Follow all instructions above, and remember: {MEMORY_UPDATE_INSTRUCTIONS_REINFORCEMENT}."
                }])
            elif tool_call["name"] == "schedule_meeting":
                content = f"User gave feedback, which we can incorporate into the meeting request. Feedback: {user_feedback}"
                update_memory(store, ("email_assistant", "cal_preferences"), state["messages"] + [{"role": "tool", "content": content, "tool_call_id": tool_call["id"]}] + [{
                    "role": "user",
                    "content": f"User gave feedback, which we can use to update the calendar preferences. Follow all instructions above, and remember: {MEMORY_UPDATE_INSTRUCTIONS_REINFORCEMENT}."
                }])
            elif tool_call["name"] == "Question":
                content = f"User answered the question, which we can use for any follow up actions. Feedback: {user_feedback}"
            else:
                content = f"User provided feedback: {user_feedback}"
            
            result.append({
                "role": "tool",
                "content": content,
                "tool_call_id": tool_call["id"]
            })
            
        else:
            raise ValueError(f"Invalid response type: {response['type']}")
    
    update = {"messages": result}
    
    if should_end_workflow:
        update["workflow_should_end"] = True
    
    return update
